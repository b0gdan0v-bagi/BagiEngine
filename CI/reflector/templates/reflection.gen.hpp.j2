// ============================================================================
// GENERATED FILE - DO NOT EDIT
// Generated from: {{ input_filename }}
// Generator: BagiEngine Reflection System (reflector.py)
// ============================================================================
#pragma once

#include <BECore/Reflection/TypeTraits.h>
#include <BECore/Utils/EnumUtils.h>
#include <EASTL/string_view.h>
#include <tuple>

{% if enums %}
// ============================================================================
// Enum Reflection
// ============================================================================
{% for enum in enums %}

// Reflection for {{ enum.qualified_name }}
// Compatible with EnumUtils<T> API
namespace EnumImpl_{{ enum.name }} {
    inline constexpr auto tokenizer = ::BECore::Impl::Tokenizer<{{ enum.qualified_name }}
        {%- for value in enum.values -%}
        , {{ enum.qualified_name }}::{{ value.name }}
        {%- endfor -%}
    >{};
}

/**
 * @brief ADL function for EnumUtils compatibility
 * @note Auto-generated from {{ enum.name }} marked with BE_REFLECT_ENUM
 */
consteval const auto* EnumTokenizerPtr({{ enum.qualified_name }}) {
    return &EnumImpl_{{ enum.name }}::tokenizer;
}

{% endfor %}
{% endif %}
{% if classes %}
// ============================================================================
// Class Reflection
// ============================================================================

namespace BECore {

{% for cls in classes %}
/**
 * @brief Reflection traits for {{ cls.qualified_name }}
 * @note Auto-generated from {{ cls.name }} marked with BE_CLASS
 *
 * Fields:
{% for field in cls.fields %}
 *   - {{ field.name }} : {{ field.type_name }}
{% endfor %}
 */
template<>
struct ReflectionTraits<{{ cls.qualified_name }}> {
    static constexpr bool reflected = true;
    static constexpr eastl::string_view name = "{{ cls.name }}";
    
    static constexpr auto fields = std::make_tuple(
{% for field in cls.fields %}
        FieldInfo{ eastl::string_view{"{{ field.name }}"}, &{{ cls.qualified_name }}::{{ field.name }} }{{ "," if not loop.last else "" }}
{% endfor %}
    );
    
    static constexpr size_t field_count = {{ cls.fields | length }};
};

{% endfor %}
}  // namespace BECore

// ============================================================================
// BE_CLASS() Static Method Implementations
// ============================================================================
{% for cls in classes %}

// {{ cls.full_qualified_name }}::GetStaticTypeName()
inline constexpr eastl::string_view {{ cls.full_qualified_name }}::GetStaticTypeName() {
    return ::BECore::ReflectionTraits<{{ cls.qualified_name }}>::name;
}

// {{ cls.full_qualified_name }}::GetStaticFieldCount()
inline constexpr size_t {{ cls.full_qualified_name }}::GetStaticFieldCount() {
    return ::BECore::ReflectionTraits<{{ cls.qualified_name }}>::field_count;
}

// {{ cls.full_qualified_name }}::ForEachFieldStatic (mutable)
template<typename Func>
inline constexpr void {{ cls.full_qualified_name }}::ForEachFieldStatic({{ cls.full_qualified_name }}& obj, Func&& func) {
    std::apply([&](auto&&... fields) {
        (func(fields.name, obj.*(fields.ptr)), ...);
    }, ::BECore::ReflectionTraits<{{ cls.qualified_name }}>::fields);
}

// {{ cls.full_qualified_name }}::ForEachFieldStatic (const)
template<typename Func>
inline constexpr void {{ cls.full_qualified_name }}::ForEachFieldStatic(const {{ cls.full_qualified_name }}& obj, Func&& func) {
    std::apply([&](auto&&... fields) {
        (func(fields.name, obj.*(fields.ptr)), ...);
    }, ::BECore::ReflectionTraits<{{ cls.qualified_name }}>::fields);
}

{% endfor %}
{% endif %}
{% if factory_bases %}
// ============================================================================
// Factory Generation (from FACTORY_BASE classes)
// ============================================================================

#include <BECore/RefCounted/IntrusivePtr.h>
#include <BECore/RefCounted/New.h>

{% for base in factory_bases %}
// ----------------------------------------------------------------------------
// Factory for {{ base.name }}
// ----------------------------------------------------------------------------

// Auto-generated enum from {{ base.name }} inheritance tree
CORE_ENUM({{ base.name }}Type, uint8_t, {% for d in base.derived %}{{ d.short_name }}{{ ", " if not loop.last else "" }}{% endfor %})

namespace {{ base.namespace }} {

/**
 * @brief Factory for creating {{ base.name }} instances
 * @note Auto-generated from BE_CLASS({{ base.name }}, FACTORY_BASE)
 *
 * Registered types:
{% for d in base.derived %}
 *   - {{ d.short_name }} -> {{ d.full_name }}
{% endfor %}
 */
class {{ base.name }}Factory {
public:
    using EnumType = {{ base.name }}Type;
    using BasePtr = IntrusivePtr<{{ base.name }}>;

    /**
     * @brief Create an instance of {{ base.name }} by type
     * @param type The type enum value
     * @return IntrusivePtr to the created instance, or empty if type is invalid
     */
    static BasePtr Create(EnumType type) {
        switch (type) {
{% for d in base.derived %}
            case EnumType::{{ d.short_name }}:
                return BECore::New<{{ d.full_name }}>();
{% endfor %}
            default:
                return {};
        }
    }

    /**
     * @brief Get the number of registered types
     * @return Number of derived classes
     */
    static constexpr size_t Count() {
        return {{ base.derived | length }};
    }

    /**
     * @brief Get the type name as string
     * @param type The type enum value
     * @return String representation of the type
     */
    static constexpr eastl::string_view GetTypeName(EnumType type) {
        return EnumUtils<EnumType>::ToString(type);
    }
};

}  // namespace {{ base.namespace }}

{% endfor %}
{% endif %}
