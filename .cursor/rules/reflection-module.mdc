---
description: Guidelines for Reflection and Serialization system
globs:
  - "**/Reflection/**/*"
  - "**/*Test*.h"
  - "**/*Test*.cpp"
alwaysApply: false
---

# Reflection System Guidelines

## Overview

Compile-time reflection system with Python-based code generation (reflector.py).

## Macros

| Macro | Location | Purpose |
|-------|----------|---------|
| `BE_CLASS(Name)` | Inside class body | Declares static reflection methods |
| `BE_CLASS(Name, FACTORY_BASE)` | Inside base class body | Enables factory/enum generation for inheritance tree |
| `BE_REFLECT_FIELD` | Before field declaration | Marks field for serialization |
| `BE_REFLECT_ENUM` | Before enum class | Enables EnumUtils compatibility |
| `BE_FUNCTION` | Before method declaration | Marks method for reflection/invocation |

## Usage Pattern

1. Add `BE_CLASS(ClassName)` inside struct/class body
2. Mark serializable fields with `BE_REFLECT_FIELD`
3. Mark callable methods with `BE_FUNCTION`
4. Include generated file in .cpp: `#include <Generated/FileName.gen.hpp>`

## Generated Type Methods

| Method | Description |
|--------|-------------|
| `GetStaticTypeName()` | Constexpr, returns type name as `eastl::string_view` |
| `GetStaticFieldCount()` | Constexpr, returns number of reflected fields |
| `GetStaticTypeMeta()` | Static constexpr, returns `ClassMeta&` for the class |
| `GetTypeMeta()` | Instance constexpr, returns actual runtime type's `ClassMeta&` |
| `Is<T>()` | Constexpr, returns true if instance is of type T |
| `Cast<T>()` | Returns `T*` if type matches, nullptr otherwise |
| `ForEachFieldStatic(obj, func)` | Constexpr, iterates over all fields |

## Method Reflection API

| Function/Concept | Description |
|------------------|-------------|
| `HasMethodReflection<T>` | Concept, true if type has reflected methods |
| `MethodCount<T>()` | Returns number of reflected methods |
| `ForEachMethod<T>(func)` | Iterates over all method infos |
| `InvokeMethod<Ret>(obj, name, args...)` | Invoke method by name, type-safe |

## Factory Generation (FACTORY_BASE)

For inheritance hierarchies, use `BE_CLASS(Name, FACTORY_BASE)` on base class.

1. Mark base class with `BE_CLASS(BaseClass, FACTORY_BASE)`
2. Mark derived classes with regular `BE_CLASS(DerivedClass)`
3. Add `SCAN_DIRS` in CMake to specify where to find derived classes
4. Include `<Generated/EnumBaseClass.gen.hpp>` — includes all dependencies

### Generated Factory API

| Method | Description |
|--------|-------------|
| `Factory::Create(EnumType)` | Static method, creates by enum |
| `Factory::Create(ClassMeta)` | Virtual method, creates by type metadata |
| `Factory::ToMeta(EnumType)` | Convert enum to ClassMeta |
| `Factory::FromMeta(ClassMeta)` | Convert ClassMeta to enum |
| `Factory::Count()` | Number of registered types |
| `Factory::GetTypeName(type)` | Get string name for type |
| `Factory::GetInstance()` | Get singleton instance |

### Naming Conventions

| Base Class | Enum Type | Factory | Enum Values |
|------------|-----------|---------|-------------|
| `ILogSink` | `LogSinkType` | `LogSinkFactory` | `Console`, `File` |
| `IWidget` | `WidgetType` | `WidgetFactory` | `ClearScreen`, `ImGui` |

Enum values computed by stripping base class suffix: `ConsoleSink` + `ILogSink` → `Console`

## CMake Configuration

Parameters for `add_reflection_target()`:
- `DIRS` — Directories to scan for headers with `BE_CLASS()` (generates .gen.hpp)
- `SCAN_DIRS` — Additional directories to scan for derived classes (factory generation)
- `INCLUDE_DIRS` — Include paths for computing include directives

## ClassMeta

Compile-time type identification without RTTI using FNV-1a hash.

| Field/Method | Description |
|--------------|-------------|
| `typeHash` | uint64_t, FNV-1a hash of type name |
| `typeName` | `eastl::string_view` |
| `operator==` | Compare by hash |
| `operator bool` | True if valid |

## Serialization

| Archive | Format | Use Case |
|---------|--------|----------|
| `XmlArchive` | XML (pugixml) | Human-readable saves, config files |
| `BinaryArchive` | Binary stream | Compact saves, network packets |

| Helper Function | Description |
|-----------------|-------------|
| `ForEachField(obj, func)` | Iterate over all reflected fields |
| `FieldCount<T>()` | Get number of reflected fields |
| `HasReflection<T>` | Concept to check if type has reflection |
| `Serialize(archive, name, obj)` | Serialize/deserialize object |

## File Structure

| Path | Contents |
|------|----------|
| `BECore/Reflection/ReflectionMarkers.h` | `BE_CLASS`, `BE_REFLECT_*`, `BE_FUNCTION` macros |
| `BECore/Reflection/TypeTraits.h` | `ReflectionTraits<T>`, `FieldInfo`, method helpers |
| `BECore/Reflection/MethodInfo.h` | `MethodInfo`, `ConstMethodInfo` structs |
| `BECore/Reflection/ClassMeta.h` | `ClassMeta` struct, `GetClassMeta<T>()` |
| `BECore/Reflection/AbstractFactory.h` | `AbstractFactory<T>` base template |
| `CI/reflector/reflector.py` | Code generator script |
| `CI/reflector/templates/*.j2` | Jinja2 templates |

## Key Points

- Use `eastl::string_view` for names (not `std::string_view`)
- Generated code is in `${CMAKE_BINARY_DIR}/Generated/`
- Python parser uses regex patterns to find `BE_CLASS()`, `BE_REFLECT_FIELD`, `BE_FUNCTION`
- `EnumXxx.gen.hpp` includes base class `.gen.hpp` and all derived `.gen.hpp`
- `Is<T>()` and `Cast<T>()` work without RTTI using embedded `_typeMeta` pointer
- Method invocation uses `if constexpr` to skip methods with incompatible signatures

## DO

- Use `BE_CLASS(ClassName)` inside class body
- Use `BE_CLASS(ClassName, FACTORY_BASE)` for factory base classes
- Mark serializable fields with `BE_REFLECT_FIELD`
- Mark callable methods with `BE_FUNCTION`
- Use `Is<T>()` and `Cast<T>()` instead of `dynamic_cast`
- Include generated headers in .cpp files only
- Include `EnumXxx.gen.hpp` for factory bases (includes all dependencies)

## DON'T

- Don't reflect pointer types directly (use IDs or special handling)
- Don't reflect reference types
- Don't modify generated files (they are overwritten)
- Don't forget the `ClassName` argument in `BE_CLASS(ClassName)`
- Don't include generated headers in .h files (causes ODR issues)
- Don't use `dynamic_cast` when `Is<T>()`/`Cast<T>()` are available
