cmake_minimum_required(VERSION 3.31)
project(MySDLGame)

# =============================================================================
# FetchContent Configuration
# =============================================================================
# Настройка базовой директории для FetchContent зависимостей
# Это должно быть установлено ДО первого include(FetchContent) в поддиректориях
# Зависимости будут сохраняться в _deps в корне проекта, вне build директории
set(FETCHCONTENT_BASE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/_deps" CACHE PATH "Directory for FetchContent dependencies" FORCE)
message(STATUS "FetchContent dependencies will be stored in: ${FETCHCONTENT_BASE_DIR}")

# После первого успешного clone не пытаться обновлять репозитории
# Это ускоряет повторную конфигурацию
set(FETCHCONTENT_UPDATES_DISCONNECTED ON CACHE BOOL "Don't update FetchContent repos after first clone")

# =============================================================================
# FetchContent Helper Macro
# =============================================================================
# Макрос для восстановления состояния populated если исходники уже существуют.
# Это позволяет избежать повторного клонирования после очистки build директории.
include(FetchContent)
macro(restore_fetchcontent_if_exists name)
    string(TOLOWER "${name}" _name_lower)
    set(_src_dir "${FETCHCONTENT_BASE_DIR}/${_name_lower}-src")
    if(EXISTS "${_src_dir}" AND IS_DIRECTORY "${_src_dir}")
        # Исходники уже существуют - восстанавливаем состояние populated
        set(FETCHCONTENT_SOURCE_DIR_${name} "${_src_dir}" CACHE PATH "" FORCE)
        message(STATUS "FetchContent: Reusing existing ${name} sources from ${_src_dir}")
    endif()
    unset(_src_dir)
    unset(_name_lower)
endmacro()

set(CMAKE_CXX_STANDARD 23)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Export compile commands for IntelliSense and other tools
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

set_property(GLOBAL PROPERTY USE_FOLDERS ON)

# =============================================================================
# Compiler Detection and Configuration
# =============================================================================
if(CMAKE_CXX_COMPILER_ID STREQUAL "Clang" OR CMAKE_CXX_COMPILER_ID STREQUAL "AppleClang")
    message(STATUS "Compiler: ${CMAKE_CXX_COMPILER_ID} ${CMAKE_CXX_COMPILER_VERSION}")
    add_compile_definitions(COMPILER_CLANG)
elseif(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    message(STATUS "Compiler: GCC ${CMAKE_CXX_COMPILER_VERSION}")
    add_compile_definitions(COMPILER_GCC)
elseif(CMAKE_CXX_COMPILER_ID MATCHES "MSVC")
    message(STATUS "Compiler: MSVC ${CMAKE_CXX_COMPILER_VERSION}")
    add_compile_definitions(COMPILER_MSVC)
else()
    message(STATUS "Compiler: ${CMAKE_CXX_COMPILER_ID} ${CMAKE_CXX_COMPILER_VERSION}")
endif()

# =============================================================================
# Platform Detection
# =============================================================================
if(WIN32)
    add_compile_definitions(PLATFORM_WINDOWS)
    message(STATUS "Platform: Windows")
elseif(APPLE)
    add_compile_definitions(PLATFORM_MACOS)
    message(STATUS "Platform: macOS")
else()
    add_compile_definitions(PLATFORM_LINUX)
    message(STATUS "Platform: Linux")
endif()

# =============================================================================
# Output Directories Configuration
# =============================================================================
# Формируем имя output директории: {Compiler}{Platform}
# CMake сам создаёт подпапки Debug/Release внутри
if(CMAKE_CXX_COMPILER_ID STREQUAL "Clang" OR CMAKE_CXX_COMPILER_ID STREQUAL "AppleClang")
    set(COMPILER_NAME "Clang")
elseif(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    set(COMPILER_NAME "GCC")
elseif(CMAKE_CXX_COMPILER_ID MATCHES "MSVC")
    set(COMPILER_NAME "MSVC")
else()
    set(COMPILER_NAME "Unknown")
endif()

if(WIN32)
    set(PLATFORM_NAME "Windows")
elseif(APPLE)
    set(PLATFORM_NAME "macOS")
else()
    set(PLATFORM_NAME "Linux")
endif()

set(OUTPUT_DIR_NAME "${COMPILER_NAME}${PLATFORM_NAME}")
set(OUTPUT_BASE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/build/${OUTPUT_DIR_NAME}")

# Executables (.exe)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${OUTPUT_BASE_DIR}")
# Shared libraries (.dll on Windows, .so on Linux)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${OUTPUT_BASE_DIR}")
# Static libraries (.lib) - keep in output directory
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${OUTPUT_BASE_DIR}/lib")

message(STATUS "Output directory: ${OUTPUT_BASE_DIR}")

# =============================================================================
# Assert System Options
# =============================================================================
option(ENGINE_ENABLE_ASSERTS "Enable ASSERT macros" ON)
option(ENGINE_ENABLE_EXPECTS "Enable EXPECT macros" ON)

# In Release builds, disable asserts by default (can be overridden)
if(CMAKE_BUILD_TYPE STREQUAL "Release")
    if(NOT DEFINED CACHE{ENGINE_ENABLE_ASSERTS})
        set(ENGINE_ENABLE_ASSERTS OFF CACHE BOOL "Enable ASSERT macros" FORCE)
    endif()
    if(NOT DEFINED CACHE{ENGINE_ENABLE_EXPECTS})
        set(ENGINE_ENABLE_EXPECTS OFF CACHE BOOL "Enable EXPECT macros" FORCE)
    endif()
endif()

# Pass defines to code
if(ENGINE_ENABLE_ASSERTS)
    add_compile_definitions(ENGINE_ENABLE_ASSERTS=1)
    message(STATUS "Asserts: ENABLED")
else()
    add_compile_definitions(ENGINE_ENABLE_ASSERTS=0)
    message(STATUS "Asserts: DISABLED")
endif()

if(ENGINE_ENABLE_EXPECTS)
    add_compile_definitions(ENGINE_ENABLE_EXPECTS=1)
    message(STATUS "Expects: ENABLED")
else()
    add_compile_definitions(ENGINE_ENABLE_EXPECTS=0)
    message(STATUS "Expects: DISABLED")
endif()

# =============================================================================
# Python Virtual Environment Detection
# =============================================================================
# Use Python from .venv/ if it exists, otherwise system Python
# This ensures all dependencies (clang, jinja2) are available

if(WIN32)
    set(VENV_PYTHON "${CMAKE_SOURCE_DIR}/.venv/Scripts/python.exe")
else()
    set(VENV_PYTHON "${CMAKE_SOURCE_DIR}/.venv/bin/python3")
endif()

if(EXISTS ${VENV_PYTHON})
    set(Python3_EXECUTABLE ${VENV_PYTHON} CACHE FILEPATH "Python interpreter from venv" FORCE)
    message(STATUS "Using Python from venv: ${VENV_PYTHON}")
else()
    message(STATUS "Venv not found at ${VENV_PYTHON}, using system Python")
    message(STATUS "  Hint: Run 'CI/setup_venv.bat' (Windows) or 'CI/setup_venv.sh' to create venv")
endif()

# =============================================================================
# Reflection System
# =============================================================================
# Find Python for the reflection code generator
find_package(Python3 COMPONENTS Interpreter)

if(Python3_FOUND)
    message(STATUS "Python3 found: ${Python3_EXECUTABLE}")
    
    # =========================================================================
    # Libclang Pre-flight Check
    # =========================================================================
    message(STATUS "Checking libclang availability...")
    
    execute_process(
        COMMAND ${Python3_EXECUTABLE} -c "
import sys
try:
    import clang.cindex
    try:
        idx = clang.cindex.Index.create()
        print('OK')
        sys.exit(0)
    except Exception:
        print('NEEDS_CONFIG')
        sys.exit(0)
except ImportError:
    print('NOT_INSTALLED')
    sys.exit(1)
"
        RESULT_VARIABLE CLANG_PY_STATUS
        OUTPUT_VARIABLE CLANG_PY_OUTPUT
        ERROR_VARIABLE CLANG_PY_ERROR
        OUTPUT_STRIP_TRAILING_WHITESPACE
    )
    
    if(CLANG_PY_STATUS EQUAL 0)
        if(CLANG_PY_OUTPUT STREQUAL "OK")
            message(STATUS "  libclang: OK")
            set(LIBCLANG_AVAILABLE TRUE)
        elseif(CLANG_PY_OUTPUT STREQUAL "NEEDS_CONFIG")
            message(STATUS "  libclang: Package installed, but library not configured")
            message(STATUS "  Run 'python CI/meta_generator/meta_generator_gui.py' to configure LLVM path")
            message(STATUS "  Or set LIBCLANG_PATH environment variable")
            set(LIBCLANG_AVAILABLE TRUE)
        endif()
    else()
        message(STATUS "  libclang: Not available (will use regex fallback)")
        set(LIBCLANG_AVAILABLE FALSE)
    endif()
    
    # Directory for generated reflection files
    # Use CMAKE_BINARY_DIR so generated files go into the actual build directory
    # (e.g., build/ClangWindowsSolution/Generated instead of build/ClangWindows/Generated)
    # Use "Generated" with capital G so include path is <Generated/File.gen.hpp>
    set(REFLECTION_GENERATED_DIR "${CMAKE_BINARY_DIR}/Generated" CACHE PATH "Directory for generated reflection files")
    file(MAKE_DIRECTORY ${REFLECTION_GENERATED_DIR})
    
    # Meta-Generator script paths (new system with caching)
    set(META_GENERATOR_SCRIPT "${CMAKE_SOURCE_DIR}/CI/meta_generator/meta_generator.py")
    set(META_GENERATOR_SETTINGS "${CMAKE_SOURCE_DIR}/meta_generator_settings.json")
    
    # Legacy reflector script (fallback if meta_generator not available)
    set(REFLECTOR_SCRIPT "${CMAKE_SOURCE_DIR}/CI/reflector/reflector.py")
    set(REFLECTOR_TEMPLATES "${CMAKE_SOURCE_DIR}/CI/reflector/templates")
    
    # =============================================================================
    # add_reflection_target - Generate reflection code for headers
    # =============================================================================
    # Usage:
    #   add_reflection_target(MyTarget
    #       DIRS
    #           ${CMAKE_CURRENT_SOURCE_DIR}/Logger
    #           ${CMAKE_CURRENT_SOURCE_DIR}/Widgets
    #       SCAN_DIRS
    #           ${CMAKE_SOURCE_DIR}/src/Widgets
    #       INCLUDE_DIRS
    #           ${CMAKE_SOURCE_DIR}/src/Modules
    #   )
    #
    # Parameters:
    #   DIRS       - Directories to scan for BE_CLASS() files
    #   SCAN_DIRS  - Additional directories to scan for derived classes (factory generation)
    #   INCLUDE_DIRS - Include paths for computing include directives
    #
    # This will:
    #   1. Run meta_generator.py with caching (only re-parses changed files)
    #   2. Generate .gen.hpp files in ${REFLECTION_GENERATED_DIR}
    #   3. For FACTORY_BASE classes, generate EnumXxx.gen.hpp with factory
    #   4. Add all generated files to target sources
    # =============================================================================
    function(add_reflection_target TARGET_NAME)
        cmake_parse_arguments(ARG "" "" "HEADERS;INCLUDE_DIRS;DIRS;SCAN_DIRS" ${ARGN})
        
        # Choose generator script: prefer meta_generator.py, fallback to reflector.py
        if(EXISTS ${META_GENERATOR_SCRIPT})
            set(GENERATOR_SCRIPT ${META_GENERATOR_SCRIPT})
            set(USE_META_GENERATOR TRUE)
        else()
            set(GENERATOR_SCRIPT ${REFLECTOR_SCRIPT})
            set(USE_META_GENERATOR FALSE)
            message(STATUS "Using legacy reflector.py (meta_generator not found)")
        endif()
        
        if(USE_META_GENERATOR)
            # =================================================================
            # NEW: Meta-Generator with caching
            # =================================================================
            # Build source directories arguments
            set(SOURCE_ARGS "")
            if(ARG_DIRS)
                foreach(DIR ${ARG_DIRS})
                    list(APPEND SOURCE_ARGS "--source-dir" "${DIR}")
                endforeach()
            endif()
            
            # Build include directories arguments
            set(INCLUDE_ARGS "")
            if(ARG_INCLUDE_DIRS)
                foreach(INC_DIR ${ARG_INCLUDE_DIRS})
                    list(APPEND INCLUDE_ARGS "--include-dir" "${INC_DIR}")
                endforeach()
            endif()
            
            # Build scan directories arguments
            set(SCAN_ARGS "")
            if(ARG_SCAN_DIRS)
                foreach(SCAN_DIR ${ARG_SCAN_DIRS})
                    list(APPEND SCAN_ARGS "--scan-dir" "${SCAN_DIR}")
                endforeach()
            elseif(ARG_DIRS)
                foreach(SCAN_DIR ${ARG_DIRS})
                    list(APPEND SCAN_ARGS "--scan-dir" "${SCAN_DIR}")
                endforeach()
            endif()
            
            message(STATUS "Running meta_generator for ${TARGET_NAME}...")
            
            execute_process(
                COMMAND ${Python3_EXECUTABLE} ${GENERATOR_SCRIPT}
                    ${SOURCE_ARGS}
                    --output-dir "${REFLECTION_GENERATED_DIR}"
                    --cache-dir "${CMAKE_BINARY_DIR}"
                    --settings "${META_GENERATOR_SETTINGS}"
                    ${INCLUDE_ARGS}
                    ${SCAN_ARGS}
                RESULT_VARIABLE META_GEN_RESULT
                OUTPUT_VARIABLE META_GEN_OUTPUT
                ERROR_VARIABLE META_GEN_ERROR
                WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
            )
            
            if(NOT META_GEN_RESULT EQUAL 0)
                message(WARNING "Meta-generator failed for ${TARGET_NAME}:")
                message(WARNING "  Exit code: ${META_GEN_RESULT}")
                message(WARNING "  Error: ${META_GEN_ERROR}")
                
                # Provide helpful error message for libclang issues
                if(META_GEN_ERROR MATCHES "libclang")
                    message(WARNING "")
                    message(WARNING "  LLVM/libclang not configured. Options:")
                    message(WARNING "    1. Run: python CI/meta_generator/meta_generator_gui.py")
                    message(WARNING "    2. Set environment variable: LIBCLANG_PATH=C:/Program Files/LLVM/bin")
                    message(WARNING "    3. Install LLVM: https://github.com/llvm/llvm-project/releases")
                endif()
            else()
                if(META_GEN_OUTPUT)
                    message(STATUS "${META_GEN_OUTPUT}")
                endif()
            endif()
            
        else()
            # =================================================================
            # LEGACY: Per-file reflector.py
            # =================================================================
            set(ALL_HEADERS "")
            
            # Build include path arguments for legacy format
            set(INCLUDE_ARGS "")
            if(ARG_INCLUDE_DIRS)
                foreach(INC_DIR ${ARG_INCLUDE_DIRS})
                    list(APPEND INCLUDE_ARGS "-I" "${INC_DIR}")
                endforeach()
            endif()
            
            # Collect headers from DIRS
            if(ARG_DIRS)
                foreach(SCAN_DIR ${ARG_DIRS})
                    if(EXISTS "${SCAN_DIR}")
                        file(GLOB_RECURSE DIR_HEADERS "${SCAN_DIR}/*.h" "${SCAN_DIR}/*.hpp")
                        foreach(HEADER ${DIR_HEADERS})
                            file(READ "${HEADER}" HEADER_CONTENT)
                            string(FIND "${HEADER_CONTENT}" "BE_CLASS(" HAS_BE_CLASS)
                            if(NOT HAS_BE_CLASS EQUAL -1)
                                list(APPEND ALL_HEADERS "${HEADER}")
                            endif()
                        endforeach()
                    endif()
                endforeach()
            endif()
            
            # Build SCAN_DIRS arguments
            set(SCAN_ARGS "")
            if(ARG_SCAN_DIRS)
                foreach(SCAN_DIR ${ARG_SCAN_DIRS})
                    list(APPEND SCAN_ARGS "-S" "${SCAN_DIR}")
                endforeach()
            elseif(ARG_DIRS)
                foreach(SCAN_DIR ${ARG_DIRS})
                    list(APPEND SCAN_ARGS "-S" "${SCAN_DIR}")
                endforeach()
            endif()
            
            foreach(HEADER ${ALL_HEADERS})
                get_filename_component(HEADER_NAME ${HEADER} NAME_WE)
                get_filename_component(HEADER_ABS ${HEADER} ABSOLUTE)
                set(GEN_FILE "${REFLECTION_GENERATED_DIR}/${HEADER_NAME}.gen.hpp")
                
                message(STATUS "Generating reflection for ${HEADER_NAME}...")
                execute_process(
                    COMMAND ${Python3_EXECUTABLE} ${REFLECTOR_SCRIPT}
                        --input "${HEADER_ABS}"
                        --output "${GEN_FILE}"
                        --templates "${REFLECTOR_TEMPLATES}"
                        ${INCLUDE_ARGS}
                        ${SCAN_ARGS}
                    RESULT_VARIABLE REFLECTOR_RESULT
                    OUTPUT_VARIABLE REFLECTOR_OUTPUT
                    ERROR_VARIABLE REFLECTOR_ERROR
                    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
                )
                
                if(NOT REFLECTOR_RESULT EQUAL 0)
                    message(WARNING "Reflection generation failed for ${HEADER_NAME}:")
                    message(WARNING "  Error: ${REFLECTOR_ERROR}")
                endif()
            endforeach()
        endif()
        
        # Collect all generated files
        file(GLOB GENERATED_FILES "${REFLECTION_GENERATED_DIR}/*.gen.hpp")
        
        if(GENERATED_FILES)
            set_source_files_properties(${GENERATED_FILES} PROPERTIES GENERATED TRUE)
            target_sources(${TARGET_NAME} PRIVATE ${GENERATED_FILES})
            list(LENGTH GENERATED_FILES GEN_COUNT)
            message(STATUS "Reflection enabled for ${TARGET_NAME}: ${GEN_COUNT} files generated")
        endif()
        
        # Add CMAKE_BINARY_DIR to include paths so <Generated/File.gen.hpp> works
        target_include_directories(${TARGET_NAME} PRIVATE ${CMAKE_BINARY_DIR})
        
        # Define REFLECTION_GENERATED so code can detect generated files are available
        target_compile_definitions(${TARGET_NAME} PRIVATE REFLECTION_GENERATED=1)
        
    endfunction()
else()
    message(WARNING "Python3 not found - reflection code generation will be disabled")
    
    # Stub function when Python is not available
    function(add_reflection_target TARGET_NAME)
        message(WARNING "add_reflection_target: Skipped (Python3 not found)")
    endfunction()
endif()

# =============================================================================
# Modules
# =============================================================================
# BECoreModule должен быть объявлен первым, так как другие модули используют его PCH
add_subdirectory(src/Modules/BECore)
add_subdirectory(src/Modules/Math)
add_subdirectory(src/Modules/Events)
add_subdirectory(src/Modules/SDL)

file(GLOB_RECURSE SOURCES 
    "src/*.cpp" 
    "src/*.h"
    "src/*.cxx"
)

list(FILTER SOURCES EXCLUDE REGEX "src/Modules/.*")

# For Windows: create WIN32 executable (no console window)
# For other platforms: create regular executable
if(WIN32)
    add_executable(MyGame WIN32 ${SOURCES})
else()
    add_executable(MyGame ${SOURCES})
endif()

source_group(TREE "${CMAKE_CURRENT_SOURCE_DIR}/src" PREFIX "Source Files" FILES ${SOURCES})

target_include_directories(MyGame PRIVATE 
    ${CMAKE_CURRENT_SOURCE_DIR}/src
)

# Настройка предкомпилированных заголовков для исполняемого файла
# REUSE_FROM позволяет переиспользовать PCH из BECoreModule без перекомпиляции
target_precompile_headers(MyGame REUSE_FROM BECoreModule)

# Автоматическое включение PCH через Force Include
# Это позволяет использовать PCH без явного #include в каждом файле
# Получаем путь к PCH header относительно include directories
# BECoreModule добавляет ${PROJECT_ROOT}/src/Modules в include directories
# PCH находится в src/Modules/BECore/pch.h, поэтому путь будет BECore/pch.h
if(MSVC)
    # MSVC: Force Include через /FI
    target_compile_options(MyGame PRIVATE /FI"BECore/pch.h")
elseif(CMAKE_CXX_COMPILER_ID STREQUAL "Clang" OR CMAKE_CXX_COMPILER_ID STREQUAL "AppleClang")
    # Clang/AppleClang: Force Include через -include
    target_compile_options(MyGame PRIVATE -include "BECore/pch.h")
elseif(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    # GCC: Force Include через -include
    target_compile_options(MyGame PRIVATE -include "BECore/pch.h")
endif()

target_link_libraries(MyGame PRIVATE 
    BECoreModule
    MathModule
    EventsModule
    SDLModule
)

# =============================================================================
# Reflection Code Generation for Application Widgets
# =============================================================================
# Generate reflection metadata for widget implementations in src/Widgets
if(COMMAND add_reflection_target)
    add_reflection_target(MyGame
        DIRS
            ${CMAKE_SOURCE_DIR}/src/Widgets
        INCLUDE_DIRS
            ${CMAKE_SOURCE_DIR}/src/Modules
            ${CMAKE_SOURCE_DIR}/src
    )
endif()

# Копирование SDL3 DLL рядом с исполняемым файлом (для Windows, если используется SDL3-shared)
if(WIN32)
    if(TARGET ${CORESDL_SDL3_TARGET})
        # Проверяем, является ли таргет shared библиотекой
        get_target_property(SDL3_TYPE ${CORESDL_SDL3_TARGET} TYPE)
        if(SDL3_TYPE STREQUAL "SHARED_LIBRARY")
            add_custom_command(TARGET MyGame POST_BUILD
                COMMAND ${CMAKE_COMMAND} -E copy_if_different
                $<TARGET_FILE:${CORESDL_SDL3_TARGET}>
                $<TARGET_FILE_DIR:MyGame>
            )
        endif()
    endif()
endif()

if(MSVC)
    set_property(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT MyGame)
endif()