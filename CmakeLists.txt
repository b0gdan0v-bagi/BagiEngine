cmake_minimum_required(VERSION 3.31)
project(MySDLGame)

# =============================================================================
# FetchContent Configuration
# =============================================================================
# Настройка базовой директории для FetchContent зависимостей
# Это должно быть установлено ДО первого include(FetchContent) в поддиректориях
# Зависимости будут сохраняться в _deps в корне проекта, вне build директории
set(FETCHCONTENT_BASE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/_deps" CACHE PATH "Directory for FetchContent dependencies" FORCE)
message(STATUS "FetchContent dependencies will be stored in: ${FETCHCONTENT_BASE_DIR}")

# После первого успешного clone не пытаться обновлять репозитории
# Это ускоряет повторную конфигурацию
set(FETCHCONTENT_UPDATES_DISCONNECTED ON CACHE BOOL "Don't update FetchContent repos after first clone")

# =============================================================================
# FetchContent Helper Macro
# =============================================================================
# Макрос для восстановления состояния populated если исходники уже существуют.
# Это позволяет избежать повторного клонирования после очистки build директории.
include(FetchContent)
macro(restore_fetchcontent_if_exists name)
    string(TOLOWER "${name}" _name_lower)
    set(_src_dir "${FETCHCONTENT_BASE_DIR}/${_name_lower}-src")
    if(EXISTS "${_src_dir}" AND IS_DIRECTORY "${_src_dir}")
        # Исходники уже существуют - восстанавливаем состояние populated
        set(FETCHCONTENT_SOURCE_DIR_${name} "${_src_dir}" CACHE PATH "" FORCE)
        message(STATUS "FetchContent: Reusing existing ${name} sources from ${_src_dir}")
    endif()
    unset(_src_dir)
    unset(_name_lower)
endmacro()

set(CMAKE_CXX_STANDARD 23)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Export compile commands for IntelliSense and other tools
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

set_property(GLOBAL PROPERTY USE_FOLDERS ON)

# =============================================================================
# Compiler Detection and Configuration
# =============================================================================
if(CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
    message(STATUS "Compiler: Clang ${CMAKE_CXX_COMPILER_VERSION}")
    add_compile_definitions(COMPILER_CLANG)
elseif(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    message(STATUS "Compiler: GCC ${CMAKE_CXX_COMPILER_VERSION}")
    add_compile_definitions(COMPILER_GCC)
elseif(CMAKE_CXX_COMPILER_ID MATCHES "MSVC")
    message(STATUS "Compiler: MSVC ${CMAKE_CXX_COMPILER_VERSION}")
    add_compile_definitions(COMPILER_MSVC)
else()
    message(STATUS "Compiler: ${CMAKE_CXX_COMPILER_ID} ${CMAKE_CXX_COMPILER_VERSION}")
endif()

# =============================================================================
# Platform Detection
# =============================================================================
if(WIN32)
    add_compile_definitions(PLATFORM_WINDOWS)
    message(STATUS "Platform: Windows")
elseif(APPLE)
    add_compile_definitions(PLATFORM_MACOS)
    message(STATUS "Platform: macOS")
else()
    add_compile_definitions(PLATFORM_LINUX)
    message(STATUS "Platform: Linux")
endif()

# =============================================================================
# Output Directories Configuration
# =============================================================================
# Формируем имя output директории: {Compiler}{Platform}
# CMake сам создаёт подпапки Debug/Release внутри
if(CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
    set(COMPILER_NAME "Clang")
elseif(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    set(COMPILER_NAME "GCC")
elseif(CMAKE_CXX_COMPILER_ID MATCHES "MSVC")
    set(COMPILER_NAME "MSVC")
else()
    set(COMPILER_NAME "Unknown")
endif()

if(WIN32)
    set(PLATFORM_NAME "Windows")
elseif(APPLE)
    set(PLATFORM_NAME "macOS")
else()
    set(PLATFORM_NAME "Linux")
endif()

set(OUTPUT_DIR_NAME "${COMPILER_NAME}${PLATFORM_NAME}")
set(OUTPUT_BASE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/build/${OUTPUT_DIR_NAME}")

# Executables (.exe)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${OUTPUT_BASE_DIR}")
# Shared libraries (.dll on Windows, .so on Linux)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${OUTPUT_BASE_DIR}")
# Static libraries (.lib) - keep in build directory
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib")

message(STATUS "Output directory: ${OUTPUT_BASE_DIR}")

# =============================================================================
# Assert System Options
# =============================================================================
option(ENGINE_ENABLE_ASSERTS "Enable ASSERT macros" ON)
option(ENGINE_ENABLE_EXPECTS "Enable EXPECT macros" ON)

# In Release builds, disable asserts by default (can be overridden)
if(CMAKE_BUILD_TYPE STREQUAL "Release")
    if(NOT DEFINED CACHE{ENGINE_ENABLE_ASSERTS})
        set(ENGINE_ENABLE_ASSERTS OFF CACHE BOOL "Enable ASSERT macros" FORCE)
    endif()
    if(NOT DEFINED CACHE{ENGINE_ENABLE_EXPECTS})
        set(ENGINE_ENABLE_EXPECTS OFF CACHE BOOL "Enable EXPECT macros" FORCE)
    endif()
endif()

# Pass defines to code
if(ENGINE_ENABLE_ASSERTS)
    add_compile_definitions(ENGINE_ENABLE_ASSERTS=1)
    message(STATUS "Asserts: ENABLED")
else()
    add_compile_definitions(ENGINE_ENABLE_ASSERTS=0)
    message(STATUS "Asserts: DISABLED")
endif()

if(ENGINE_ENABLE_EXPECTS)
    add_compile_definitions(ENGINE_ENABLE_EXPECTS=1)
    message(STATUS "Expects: ENABLED")
else()
    add_compile_definitions(ENGINE_ENABLE_EXPECTS=0)
    message(STATUS "Expects: DISABLED")
endif()

# =============================================================================
# Reflection System
# =============================================================================
# Find Python for the reflection code generator
find_package(Python3 COMPONENTS Interpreter)

if(Python3_FOUND)
    message(STATUS "Python3 found: ${Python3_EXECUTABLE}")
    
    # Directory for generated reflection files
    set(REFLECTION_GENERATED_DIR "${CMAKE_BINARY_DIR}/generated" CACHE PATH "Directory for generated reflection files")
    file(MAKE_DIRECTORY ${REFLECTION_GENERATED_DIR})
    
    # Reflector script and templates paths
    set(REFLECTOR_SCRIPT "${CMAKE_SOURCE_DIR}/CI/reflector/reflector.py")
    set(REFLECTOR_TEMPLATES "${CMAKE_SOURCE_DIR}/CI/reflector/templates")
    
    # =============================================================================
    # add_reflection_target - Generate reflection code for headers
    # =============================================================================
    # Usage:
    #   add_reflection_target(MyTarget
    #       HEADERS
    #           ${CMAKE_CURRENT_SOURCE_DIR}/Player.h
    #           ${CMAKE_CURRENT_SOURCE_DIR}/GameState.h
    #       INCLUDE_DIRS
    #           ${CMAKE_SOURCE_DIR}/src/Modules
    #   )
    #
    # This will:
    #   1. Run reflector.py at CONFIGURE TIME (execute_process)
    #   2. Generate .gen.hpp files in ${REFLECTION_GENERATED_DIR}
    #   3. Add generated files to target sources
    #   4. Add generated directory to target include paths
    #   5. Also add custom_command for incremental rebuilds at build time
    # =============================================================================
    function(add_reflection_target TARGET_NAME)
        cmake_parse_arguments(ARG "" "" "HEADERS;INCLUDE_DIRS" ${ARGN})
        
        if(NOT ARG_HEADERS)
            message(WARNING "add_reflection_target: No HEADERS specified for ${TARGET_NAME}")
            return()
        endif()
        
        set(GENERATED_FILES "")
        
        # Build include path arguments
        set(INCLUDE_ARGS "")
        if(ARG_INCLUDE_DIRS)
            foreach(INC_DIR ${ARG_INCLUDE_DIRS})
                list(APPEND INCLUDE_ARGS "-I" "${INC_DIR}")
            endforeach()
        endif()
        
        foreach(HEADER ${ARG_HEADERS})
            # Get filename without extension for output file
            get_filename_component(HEADER_NAME ${HEADER} NAME_WE)
            get_filename_component(HEADER_ABS ${HEADER} ABSOLUTE)
            
            set(GEN_FILE "${REFLECTION_GENERATED_DIR}/${HEADER_NAME}.gen.hpp")
            list(APPEND GENERATED_FILES ${GEN_FILE})
            
            # =================================================================
            # CONFIGURE TIME: Generate via execute_process
            # Files are created immediately, IDE sees them after configure
            # =================================================================
            message(STATUS "Generating reflection for ${HEADER_NAME}...")
            execute_process(
                COMMAND ${Python3_EXECUTABLE} ${REFLECTOR_SCRIPT}
                    --input "${HEADER_ABS}"
                    --output "${GEN_FILE}"
                    --templates "${REFLECTOR_TEMPLATES}"
                    ${INCLUDE_ARGS}
                RESULT_VARIABLE REFLECTOR_RESULT
                OUTPUT_VARIABLE REFLECTOR_OUTPUT
                ERROR_VARIABLE REFLECTOR_ERROR
                WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
            )
            
            if(NOT REFLECTOR_RESULT EQUAL 0)
                message(WARNING "Reflection generation failed for ${HEADER_NAME}:")
                message(WARNING "  Exit code: ${REFLECTOR_RESULT}")
                message(WARNING "  Error: ${REFLECTOR_ERROR}")
            else()
                message(STATUS "  Generated: ${GEN_FILE}")
            endif()
        endforeach()
        
        # Add generated files to target sources
        target_sources(${TARGET_NAME} PRIVATE ${GENERATED_FILES})
        
        # Add generated directory to include paths
        target_include_directories(${TARGET_NAME} PRIVATE ${REFLECTION_GENERATED_DIR})
        
        # Define REFLECTION_GENERATED so code can detect generated files are available
        target_compile_definitions(${TARGET_NAME} PRIVATE REFLECTION_GENERATED=1)
        
        message(STATUS "Reflection enabled for ${TARGET_NAME}: ${ARG_HEADERS}")
    endfunction()
else()
    message(WARNING "Python3 not found - reflection code generation will be disabled")
    
    # Stub function when Python is not available
    function(add_reflection_target TARGET_NAME)
        message(WARNING "add_reflection_target: Skipped (Python3 not found)")
    endfunction()
endif()

# =============================================================================
# Modules
# =============================================================================
# BECoreModule должен быть объявлен первым, так как другие модули используют его PCH
add_subdirectory(src/Modules/BECore)
add_subdirectory(src/Modules/Math)
add_subdirectory(src/Modules/Events)
add_subdirectory(src/Modules/SDL)

file(GLOB_RECURSE SOURCES 
    "src/*.cpp" 
    "src/*.h"
    "src/*.cxx"
)

list(FILTER SOURCES EXCLUDE REGEX "src/Modules/.*")

# For Windows: create WIN32 executable (no console window)
# For other platforms: create regular executable
if(WIN32)
    add_executable(MyGame WIN32 ${SOURCES})
else()
    add_executable(MyGame ${SOURCES})
endif()

source_group(TREE "${CMAKE_CURRENT_SOURCE_DIR}/src" PREFIX "Source Files" FILES ${SOURCES})

target_include_directories(MyGame PRIVATE 
    ${CMAKE_CURRENT_SOURCE_DIR}/src
)

# Настройка предкомпилированных заголовков для исполняемого файла
# REUSE_FROM позволяет переиспользовать PCH из BECoreModule без перекомпиляции
target_precompile_headers(MyGame REUSE_FROM BECoreModule)

# Автоматическое включение PCH через Force Include
# Это позволяет использовать PCH без явного #include в каждом файле
# Получаем путь к PCH header относительно include directories
# BECoreModule добавляет ${PROJECT_ROOT}/src/Modules в include directories
# PCH находится в src/Modules/BECore/pch.h, поэтому путь будет BECore/pch.h
if(MSVC)
    # MSVC: Force Include через /FI
    target_compile_options(MyGame PRIVATE /FI"BECore/pch.h")
elseif(CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
    # Clang: Force Include через -include
    target_compile_options(MyGame PRIVATE -include "BECore/pch.h")
elseif(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    # GCC: Force Include через -include
    target_compile_options(MyGame PRIVATE -include "BECore/pch.h")
endif()

target_link_libraries(MyGame PRIVATE 
    BECoreModule
    MathModule
    EventsModule
    SDLModule
)

# Копирование SDL3 DLL рядом с исполняемым файлом (для Windows, если используется SDL3-shared)
if(WIN32)
    if(TARGET ${CORESDL_SDL3_TARGET})
        # Проверяем, является ли таргет shared библиотекой
        get_target_property(SDL3_TYPE ${CORESDL_SDL3_TARGET} TYPE)
        if(SDL3_TYPE STREQUAL "SHARED_LIBRARY")
            add_custom_command(TARGET MyGame POST_BUILD
                COMMAND ${CMAKE_COMMAND} -E copy_if_different
                $<TARGET_FILE:${CORESDL_SDL3_TARGET}>
                $<TARGET_FILE_DIR:MyGame>
            )
        endif()
    endif()
endif()

if(MSVC)
    set_property(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT MyGame)
endif()