cmake_minimum_required(VERSION 3.31)
project(MySDLGame)

# =============================================================================
# External Dependencies
# =============================================================================
# Build external libraries directly instead of using a separate SDK build

include(FetchContent)

# EA Libraries (Vendored EABase + EASTL)
message(STATUS "Configuring EA Libraries (vendored)...")
add_subdirectory(src/Modules/EABase)

# SDL3 - Shared library
message(STATUS "Configuring SDL3...")
set(SDL_SHARED ON CACHE BOOL "Build SDL3 as shared library" FORCE)
set(SDL_STATIC OFF CACHE BOOL "Build SDL3 as static library" FORCE)
set(SDL_TEST OFF CACHE BOOL "Build SDL3 tests" FORCE)
set(SDL_TESTS OFF CACHE BOOL "Build SDL3 tests" FORCE)
add_subdirectory(external/SDL)

# fmt - Static library
message(STATUS "Configuring fmt...")
set(FMT_INSTALL OFF CACHE BOOL "Generate fmt install target" FORCE)
set(FMT_TEST OFF CACHE BOOL "Build fmt tests" FORCE)
set(FMT_DOC OFF CACHE BOOL "Build fmt documentation" FORCE)
add_subdirectory(external/fmt)

# Vendored libraries (EnTT, pugixml, ImGui)
message(STATUS "Configuring vendored libraries...")
add_subdirectory(src/Modules/EnTT)
add_subdirectory(src/Modules/pugixml)
add_subdirectory(src/Modules/imgui)

# Group external libraries in IDE
set_target_properties(SDL3-shared PROPERTIES FOLDER "External")
set_target_properties(fmt PROPERTIES FOLDER "External")

set(CMAKE_CXX_STANDARD 23)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Export compile commands for IntelliSense and other tools
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

set_property(GLOBAL PROPERTY USE_FOLDERS ON)

# =============================================================================
# Compiler Detection and Configuration
# =============================================================================
if(CMAKE_CXX_COMPILER_ID STREQUAL "Clang" OR CMAKE_CXX_COMPILER_ID STREQUAL "AppleClang")
    message(STATUS "Compiler: ${CMAKE_CXX_COMPILER_ID} ${CMAKE_CXX_COMPILER_VERSION}")
    add_compile_definitions(COMPILER_CLANG)
elseif(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    message(STATUS "Compiler: GCC ${CMAKE_CXX_COMPILER_VERSION}")
    add_compile_definitions(COMPILER_GCC)
elseif(CMAKE_CXX_COMPILER_ID MATCHES "MSVC")
    message(STATUS "Compiler: MSVC ${CMAKE_CXX_COMPILER_VERSION}")
    add_compile_definitions(COMPILER_MSVC)
else()
    message(STATUS "Compiler: ${CMAKE_CXX_COMPILER_ID} ${CMAKE_CXX_COMPILER_VERSION}")
endif()

# =============================================================================
# Platform Detection
# =============================================================================
if(WIN32)
    add_compile_definitions(PLATFORM_WINDOWS)
    message(STATUS "Platform: Windows")
elseif(APPLE)
    add_compile_definitions(PLATFORM_MACOS)
    message(STATUS "Platform: macOS")
else()
    add_compile_definitions(PLATFORM_LINUX)
    message(STATUS "Platform: Linux")
endif()

# =============================================================================
# Output Directories Configuration
# =============================================================================
# Формируем имя output директории: {Compiler}{Platform}
# CMake сам создаёт подпапки Debug/Release внутри
if(CMAKE_CXX_COMPILER_ID STREQUAL "Clang" OR CMAKE_CXX_COMPILER_ID STREQUAL "AppleClang")
    set(COMPILER_NAME "Clang")
elseif(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    set(COMPILER_NAME "GCC")
elseif(CMAKE_CXX_COMPILER_ID MATCHES "MSVC")
    set(COMPILER_NAME "MSVC")
else()
    set(COMPILER_NAME "Unknown")
endif()

if(WIN32)
    set(PLATFORM_NAME "Windows")
elseif(APPLE)
    set(PLATFORM_NAME "macOS")
else()
    set(PLATFORM_NAME "Linux")
endif()

set(OUTPUT_DIR_NAME "${COMPILER_NAME}${PLATFORM_NAME}")
set(OUTPUT_BASE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/build/${OUTPUT_DIR_NAME}")

# Executables (.exe)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${OUTPUT_BASE_DIR}")
# Shared libraries (.dll on Windows, .so on Linux)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${OUTPUT_BASE_DIR}")
# Static libraries (.lib) - keep in output directory
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${OUTPUT_BASE_DIR}/lib")

message(STATUS "Output directory: ${OUTPUT_BASE_DIR}")

# =============================================================================
# Assert System Options
# =============================================================================
option(ENGINE_ENABLE_ASSERTS "Enable ASSERT macros" ON)
option(ENGINE_ENABLE_EXPECTS "Enable EXPECT macros" ON)

# In Release builds, disable asserts by default (can be overridden)
if(CMAKE_BUILD_TYPE STREQUAL "Release")
    if(NOT DEFINED CACHE{ENGINE_ENABLE_ASSERTS})
        set(ENGINE_ENABLE_ASSERTS OFF CACHE BOOL "Enable ASSERT macros" FORCE)
    endif()
    if(NOT DEFINED CACHE{ENGINE_ENABLE_EXPECTS})
        set(ENGINE_ENABLE_EXPECTS OFF CACHE BOOL "Enable EXPECT macros" FORCE)
    endif()
endif()

# Pass defines to code
if(ENGINE_ENABLE_ASSERTS)
    add_compile_definitions(ENGINE_ENABLE_ASSERTS=1)
    message(STATUS "Asserts: ENABLED")
else()
    add_compile_definitions(ENGINE_ENABLE_ASSERTS=0)
    message(STATUS "Asserts: DISABLED")
endif()

if(ENGINE_ENABLE_EXPECTS)
    add_compile_definitions(ENGINE_ENABLE_EXPECTS=1)
    message(STATUS "Expects: ENABLED")
else()
    add_compile_definitions(ENGINE_ENABLE_EXPECTS=0)
    message(STATUS "Expects: DISABLED")
endif()

# =============================================================================
# Python Virtual Environment Detection
# =============================================================================
# Use Python from .venv/ if it exists, otherwise system Python
# This ensures all dependencies (clang, jinja2) are available

if(WIN32)
    set(VENV_PYTHON "${CMAKE_SOURCE_DIR}/.venv/Scripts/python.exe")
else()
    set(VENV_PYTHON "${CMAKE_SOURCE_DIR}/.venv/bin/python3")
endif()

if(EXISTS ${VENV_PYTHON})
    set(Python3_EXECUTABLE ${VENV_PYTHON} CACHE FILEPATH "Python interpreter from venv" FORCE)
    message(STATUS "Using Python from venv: ${VENV_PYTHON}")
else()
    message(STATUS "Venv not found at ${VENV_PYTHON}, using system Python")
    message(STATUS "  Hint: Run 'CI/setup_venv.bat' (Windows) or 'CI/setup_venv.sh' to create venv")
endif()

# =============================================================================
# Reflection System
# =============================================================================
# Find Python for the reflection code generator
find_package(Python3 COMPONENTS Interpreter)

if(Python3_FOUND)
    message(STATUS "Python3 found: ${Python3_EXECUTABLE}")
    
    # =========================================================================
    # Libclang Pre-flight Check
    # =========================================================================
    message(STATUS "Checking libclang availability...")
    
    execute_process(
        COMMAND ${Python3_EXECUTABLE} -c "
import sys
try:
    import clang.cindex
    try:
        idx = clang.cindex.Index.create()
        print('OK')
        sys.exit(0)
    except Exception:
        print('NEEDS_CONFIG')
        sys.exit(0)
except ImportError:
    print('NOT_INSTALLED')
    sys.exit(1)
"
        RESULT_VARIABLE CLANG_PY_STATUS
        OUTPUT_VARIABLE CLANG_PY_OUTPUT
        ERROR_VARIABLE CLANG_PY_ERROR
        OUTPUT_STRIP_TRAILING_WHITESPACE
    )
    
    if(CLANG_PY_STATUS EQUAL 0)
        if(CLANG_PY_OUTPUT STREQUAL "OK")
            message(STATUS "  libclang: OK")
            set(LIBCLANG_AVAILABLE TRUE)
        elseif(CLANG_PY_OUTPUT STREQUAL "NEEDS_CONFIG")
            message(STATUS "  libclang: Package installed, but library not configured")
            message(STATUS "  Run 'python CI/meta_generator/meta_generator_gui.py' to configure LLVM path")
            message(STATUS "  Or set LIBCLANG_PATH environment variable")
            set(LIBCLANG_AVAILABLE TRUE)
        endif()
    else()
        message(WARNING "  libclang: Not available (LLVM is REQUIRED for reflection generation)")
        message(WARNING "  Options:")
        message(WARNING "    1. Run: python CI/meta_generator/meta_generator_gui.py")
        message(WARNING "    2. Set environment variable: LIBCLANG_PATH=C:/Program Files/LLVM/bin")
        message(WARNING "    3. Install LLVM: https://github.com/llvm/llvm-project/releases")
        set(LIBCLANG_AVAILABLE FALSE)
    endif()
    
    # Directory for generated reflection files
    # Use CMAKE_BINARY_DIR so generated files go into the actual build directory
    # (e.g., build/ClangWindowsSolution/Generated instead of build/ClangWindows/Generated)
    # Use "Generated" with capital G so include path is <Generated/File.gen.hpp>
    set(REFLECTION_GENERATED_DIR "${CMAKE_BINARY_DIR}/Generated" CACHE PATH "Directory for generated reflection files")
    file(MAKE_DIRECTORY ${REFLECTION_GENERATED_DIR})
    
    # Meta-Generator script paths (LLVM-based, requires libclang)
    set(META_GENERATOR_SCRIPT "${CMAKE_SOURCE_DIR}/CI/meta_generator/meta_generator.py")
    set(META_GENERATOR_SETTINGS "${CMAKE_SOURCE_DIR}/meta_generator_settings.json")
    
    # =============================================================================
    # add_reflection_target - Generate reflection code for headers
    # =============================================================================
    # Usage:
    #   add_reflection_target(MyTarget
    #       DIRS
    #           ${CMAKE_CURRENT_SOURCE_DIR}/Logger
    #           ${CMAKE_CURRENT_SOURCE_DIR}/Widgets
    #       SCAN_DIRS
    #           ${CMAKE_SOURCE_DIR}/src/Widgets
    #       INCLUDE_DIRS
    #           ${CMAKE_SOURCE_DIR}/src/Modules
    #   )
    #
    # Parameters:
    #   DIRS       - Directories to scan for BE_CLASS() files
    #   SCAN_DIRS  - Additional directories to scan for derived classes (factory generation)
    #   INCLUDE_DIRS - Include paths for computing include directives
    #
    # This will:
    #   1. Run meta_generator.py with caching (only re-parses changed files)
    #   2. Generate .gen.hpp files in ${REFLECTION_GENERATED_DIR}
    #   3. For FACTORY_BASE classes, generate EnumXxx.gen.hpp with factory
    #   4. Add all generated files to target sources
    # =============================================================================
    function(add_reflection_target TARGET_NAME)
        cmake_parse_arguments(ARG "" "" "HEADERS;INCLUDE_DIRS;DIRS;SCAN_DIRS" ${ARGN})
        
        # Check that meta_generator.py exists
        if(NOT EXISTS ${META_GENERATOR_SCRIPT})
            message(FATAL_ERROR "Meta-generator script not found: ${META_GENERATOR_SCRIPT}")
        endif()
        
        # Build source directories arguments
        set(SOURCE_ARGS "")
        if(ARG_DIRS)
            foreach(DIR ${ARG_DIRS})
                list(APPEND SOURCE_ARGS "--source-dir" "${DIR}")
            endforeach()
        endif()
        
        # Build include directories arguments
        set(INCLUDE_ARGS "")
        if(ARG_INCLUDE_DIRS)
            foreach(INC_DIR ${ARG_INCLUDE_DIRS})
                list(APPEND INCLUDE_ARGS "--include-dir" "${INC_DIR}")
            endforeach()
        endif()
        
        # Build scan directories arguments
        set(SCAN_ARGS "")
        if(ARG_SCAN_DIRS)
            foreach(SCAN_DIR ${ARG_SCAN_DIRS})
                list(APPEND SCAN_ARGS "--scan-dir" "${SCAN_DIR}")
            endforeach()
        elseif(ARG_DIRS)
            foreach(SCAN_DIR ${ARG_DIRS})
                list(APPEND SCAN_ARGS "--scan-dir" "${SCAN_DIR}")
            endforeach()
        endif()
        
        message(STATUS "Running meta_generator for ${TARGET_NAME}...")
        
        # Create cache directory specific to configuration
        set(META_CACHE_DIR "${CMAKE_BINARY_DIR}/.meta_cache")
        file(MAKE_DIRECTORY "${META_CACHE_DIR}")
        
        execute_process(
            COMMAND ${Python3_EXECUTABLE} ${META_GENERATOR_SCRIPT}
                ${SOURCE_ARGS}
                --output-dir "${REFLECTION_GENERATED_DIR}"
                --cache-dir "${META_CACHE_DIR}"
                --settings "${META_GENERATOR_SETTINGS}"
                ${INCLUDE_ARGS}
                ${SCAN_ARGS}
            RESULT_VARIABLE META_GEN_RESULT
            OUTPUT_VARIABLE META_GEN_OUTPUT
            ERROR_VARIABLE META_GEN_ERROR
            WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
        )
        
        if(NOT META_GEN_RESULT EQUAL 0)
            message(FATAL_ERROR "Meta-generator failed for ${TARGET_NAME}:\n"
                "  Exit code: ${META_GEN_RESULT}\n"
                "  Error: ${META_GEN_ERROR}\n"
                "\n"
                "LLVM/libclang is REQUIRED. Options:\n"
                "  1. Run: python CI/meta_generator/meta_generator_gui.py (configure LLVM path)\n"
                "  2. Set environment variable: LIBCLANG_PATH=C:/Program Files/LLVM/bin\n"
                "  3. Install LLVM: https://github.com/llvm/llvm-project/releases"
            )
        else()
            if(META_GEN_OUTPUT)
                message(STATUS "${META_GEN_OUTPUT}")
            endif()
        endif()
        
        # Collect all generated files
        file(GLOB GENERATED_FILES "${REFLECTION_GENERATED_DIR}/*.gen.hpp")
        
        if(GENERATED_FILES)
            set_source_files_properties(${GENERATED_FILES} PROPERTIES GENERATED TRUE)
            target_sources(${TARGET_NAME} PRIVATE ${GENERATED_FILES})
            list(LENGTH GENERATED_FILES GEN_COUNT)
            message(STATUS "Reflection enabled for ${TARGET_NAME}: ${GEN_COUNT} files generated")
        endif()
        
        # Add CMAKE_BINARY_DIR to include paths so <Generated/File.gen.hpp> works
        target_include_directories(${TARGET_NAME} PRIVATE ${CMAKE_BINARY_DIR})
        
        # Define REFLECTION_GENERATED so code can detect generated files are available
        target_compile_definitions(${TARGET_NAME} PRIVATE REFLECTION_GENERATED=1)
        
    endfunction()
else()
    message(WARNING "Python3 not found - reflection code generation will be disabled")
    
    # Stub function when Python is not available
    function(add_reflection_target TARGET_NAME)
        message(WARNING "add_reflection_target: Skipped (Python3 not found)")
    endfunction()
endif()

# =============================================================================
# Modules
# =============================================================================
# BECoreModule должен быть объявлен первым, так как другие модули используют его PCH
add_subdirectory(src/Modules/BECore)
add_subdirectory(src/Modules/Math)
add_subdirectory(src/Modules/Events)
add_subdirectory(src/Modules/TaskSystem)
add_subdirectory(src/Modules/SDL)

file(GLOB_RECURSE SOURCES 
    "src/*.cpp" 
    "src/*.h"
    "src/*.cxx"
)

list(FILTER SOURCES EXCLUDE REGEX "src/Modules/.*")

# For Windows: create WIN32 executable (no console window)
# For other platforms: create regular executable
if(WIN32)
    add_executable(MyGame WIN32 ${SOURCES})
else()
    add_executable(MyGame ${SOURCES})
endif()

source_group(TREE "${CMAKE_CURRENT_SOURCE_DIR}/src" PREFIX "Source Files" FILES ${SOURCES})

target_include_directories(MyGame PRIVATE 
    ${CMAKE_CURRENT_SOURCE_DIR}/src
)

# Настройка предкомпилированных заголовков для исполняемого файла
# REUSE_FROM позволяет переиспользовать PCH из BECoreModule без перекомпиляции
target_precompile_headers(MyGame REUSE_FROM BECoreModule)

# Автоматическое включение PCH через Force Include
# Это позволяет использовать PCH без явного #include в каждом файле
# Получаем путь к PCH header относительно include directories
# BECoreModule добавляет ${PROJECT_ROOT}/src/Modules в include directories
# PCH находится в src/Modules/BECore/pch.h, поэтому путь будет BECore/pch.h
if(MSVC)
    # MSVC: Force Include через /FI
    target_compile_options(MyGame PRIVATE /FI"BECore/pch.h")
elseif(CMAKE_CXX_COMPILER_ID STREQUAL "Clang" OR CMAKE_CXX_COMPILER_ID STREQUAL "AppleClang")
    # Clang/AppleClang: Force Include через -include
    target_compile_options(MyGame PRIVATE -include "BECore/pch.h")
elseif(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    # GCC: Force Include через -include
    target_compile_options(MyGame PRIVATE -include "BECore/pch.h")
endif()

target_link_libraries(MyGame PRIVATE 
    BECoreModule
    MathModule
    EventsModule
    TaskSystemModule
    SDLModule
)

# =============================================================================
# Reflection Code Generation for Application Widgets
# =============================================================================
# Generate reflection metadata for widget implementations in src/Widgets
if(COMMAND add_reflection_target)
    add_reflection_target(MyGame
        DIRS
            ${CMAKE_SOURCE_DIR}/src/Widgets
        INCLUDE_DIRS
            ${CMAKE_SOURCE_DIR}/src/Modules
            ${CMAKE_SOURCE_DIR}/src
    )
endif()

# Копирование SDL3 DLL рядом с исполняемым файлом (для Windows)
if(WIN32)
    if(TARGET SDL3-shared)
        add_custom_command(TARGET MyGame POST_BUILD
            COMMAND ${CMAKE_COMMAND} -E copy_if_different
            $<TARGET_FILE:SDL3-shared>
            $<TARGET_FILE_DIR:MyGame>
        )
    endif()
endif()

if(MSVC)
    set_property(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT MyGame)
endif()