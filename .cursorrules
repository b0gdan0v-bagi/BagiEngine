# BagiEngine - Cursor AI Rules

## Project Overview

BagiEngine is a C++23 game engine with modular architecture built using modern C++ practices.

## Technology Stack

- **Language**: C++23 (CMAKE_CXX_STANDARD 23)
- **Build System**: CMake 3.31+ with Ninja generator
- **Graphics**: SDL3, ImGui
- **ECS**: EnTT
- **Containers**: EASTL (EA's STL - preferred over std:: containers)
- **XML**: pugixml
- **Formatting**: fmt library
- **Reflection**: magic_enum

## Project Structure

```
src/
├── Application/          # Main application entry point
├── Widgets/              # Game-specific widgets (ClearScreenWidget, ImGuiWidget)
└── Modules/
    ├── BECore/           # Core engine functionality
    │   ├── Application/  # Application lifecycle (Fabric, MainAccess)
    │   ├── Config/       # XML configuration system (XmlConfig, XmlNode)
    │   ├── FileSystem/   # Virtual filesystem with mount points
    │   ├── Format/       # Custom formatting utilities
    │   ├── GameManager/  # Core game loop management
    │   ├── MainWindow/   # Window management interfaces
    │   ├── PoolString/   # Optimized string pooling system
    │   ├── RefCounted/   # Reference counting (IntrusivePtr, RefCounted)
    │   ├── Utils/        # Singleton, PassKey, EnumUtils, etc.
    │   └── Widgets/      # Widget system (IWidget interface)
    ├── Events/           # Event system using EnTT dispatcher
    ├── Math/             # Math utilities (Color, vectors)
    └── SDL/              # SDL3 integration
config/                   # XML configuration files
```

## Code Style Guidelines

### Naming Conventions

- **Classes**: PascalCase (e.g., `FileSystem`, `CoreManager`)
- **Methods**: PascalCase (e.g., `Initialize()`, `GetInstance()`)
- **Variables**: camelCase (e.g., `virtualPath`, `realPath`)
- **Private members**: underscore prefix (e.g., `_isRunning`, `_rootPath`, `_mountPoints`)
- **Namespaces**: PascalCase (e.g., `BECore`, `Math`, `SDLEvents`)
- **Constants/Enums**: PascalCase (e.g., `ApplicationSystemType`)

### File Structure

```cpp
#pragma once  // Always use pragma once, never include guards

#include <...>  // Standard/External includes first
#include <BECore/...>  // Then internal includes

namespace BECore {

    /**
     * Doxygen-style documentation for classes
     */
    class MyClass : public Singleton<MyClass> {
    public:
        MyClass() = default;
        ~MyClass() override = default;

        // Public methods
        void PublicMethod();

    private:
        // Private members with underscore prefix
        bool _isInitialized = false;
    };

}  // namespace BECore  <- Always add namespace comment
```

### Key Patterns Used

1. **Singleton Pattern** - For global services:
   ```cpp
   class MyService : public Singleton<MyService> {
       // Use GetInstance() to access
   };
   ```

2. **PassKey Pattern** - For access control:
   ```cpp
   void RestrictedMethod(PassKey<AllowedClass>);
   // Only AllowedClass can call this method
   ```

3. **RefCounted + IntrusivePtr** - For reference counting:
   ```cpp
   class MyObject : public RefCounted {
       // Use IntrusivePtr<MyObject> for smart pointers
   };
   ```

4. **Event System (CRTP)** - For events:
   ```cpp
   struct MyEvent : EventBase<MyEvent> {
       // Use Subscribe<&Handler>(), Emit(), Enqueue()
   };
   ```

5. **Widget System** - For UI/rendering:
   ```cpp
   class MyWidget : public IWidget {
       bool Initialize(const XmlNode& node) override;
       void Update() override;
       void Draw() override;
   };
   ```

## Important Guidelines

### DO:
- Use `PoolString` instead of `std::string` for frequently used strings
- Use EASTL containers (`eastl::vector`, `eastl::hash_map`) over std:: equivalents
- Inherit from `Singleton<T>` for global services
- Use `PassKey<T>` pattern to restrict method access
- Document public APIs with Doxygen-style comments
- Use `#pragma once` for header guards
- Add namespace closing comments: `}  // namespace BECore`
- Initialize member variables inline: `bool _flag = false;`
- Use `override` keyword for virtual methods
- Use C++20/23 features: concepts, ranges, `std::filesystem`

### DON'T:
- Don't use raw `new`/`delete` - use `IntrusivePtr` or EASTL smart pointers
- Don't use `std::string` when `PoolString` is more appropriate
- Don't create circular dependencies between modules
- Don't add public constructors to Singletons
- Don't forget to close namespaces with comments
- Don't use C-style casts - use `static_cast`, `dynamic_cast`, etc.

## Module Dependencies

```
BECore (base module, no dependencies except external libs)
  ↑
Math (depends on BECore)
  ↑
Events (depends on BECore, uses EnTT)
  ↑
SDL (depends on BECore, Events, uses SDL3)
  ↑
Application (depends on all modules)
```

## Precompiled Headers (PCH)

The project uses PCH from `src/Modules/BECore/pch.h`. This includes:
- pugixml
- magic_enum
- EASTL containers
- Standard library headers
- Core utilities (Singleton, PassKey, PoolString, etc.)

When adding new files, these headers are automatically available without explicit includes.

## Configuration System

XML configs are stored in `config/` directory:
- `ApplicationConfig.xml` - Main application settings
- `SDLWindowConfig.xml` - Window configuration
- `WidgetsConfig.xml` - Widget definitions

Access configs via:
```cpp
XmlConfig config;
if (config.Load("config/MyConfig.xml")) {
    XmlNode node = config.GetRoot();
    // ...
}
```

## Virtual FileSystem

Use FileSystem for file access:
```cpp
FileSystem::GetInstance().Mount("assets", "./assets");
auto path = FileSystem::GetInstance().ResolvePath("assets/texture.png");
```

## Building

```bash
# Configure (Ninja)
cmake -B build -G Ninja

# Build
cmake --build build

# Run
./build/MyGame
```

## Platform Support

- macOS (Apple Silicon + Intel)
- Windows (MSVC, MinGW)
- Linux (GCC, Clang)
